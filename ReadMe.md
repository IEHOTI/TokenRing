# TokenRing Simulation

Имитационная модель кольцевой сети с передачей токенов-сообщений между узлами.

## Описание проекта

Проект реализует кольцевую сеть узлов, где каждый узел может отправлять и получать сообщения (токены). Сообщения передаются по кольцу до достижения получателя или истечения TTL (Time To Live).

## Особенности

- **Кольцевая топология** - узлы соединены в кольцо
- **TTL механизм** - предотвращает бесконечную циркуляцию сообщений
- **Асинхронная обработка** - каждый узел работает в отдельной goroutine
- **SHA3-256 хеширование** - для идентификации получателей
- **Автогенерация сообщений** - узлы автоматически создают новые сообщения

## Структура проекта

```
main.go              # Основная программа и точка входа
models.go            # Структуры данных (Token, Node)
nodesFunc.go         # Создание и управление узлом
tokenFunc.go         # Создание и отправка сообщений 
common.go            # Дополнительные функции
```

## Установка и запуск

### Требования
- Go 1.25.0 или выше

### Запуск
```bash
# Сборка и запуск с количеством узлов по умолчанию (3)
go run *.go

# Запуск с указанием количества узлов
go run *.go -nodes=5

# Сборка бинарного файла
go build -o ring-network
./ring-network -nodes=10
```

## Параметры командной строки

- `-nodes` - количество узлов в кольцевой сети (по умолчанию: 3, минимум: 2)

## Как это работает

1. Создается кольцевая сеть из N узлов
2. Главный поток отправляет первое сообщение в сеть
3. Узлы передают сообщения по кольцу
4. Когда узел получает сообщение, предназначенное ему:
   - Выводит информацию о сообщении
   - Генерирует новое случайное сообщение
5. Сообщения имеют TTL, который уменьшается при каждой передаче
6. Программа работает 30 секунд (для наглядности), затем выводит статистику

## Пример вывода

```
Создание кольцевой сети из 5 узлов...

Главный поток: Отправляю первое сообщение узлу 3 через узел 0
Всего узлов в кольце: 5

[TTL=9] Узел 0: Отправка сообщения следующему узлу
[TTL=8] Узел 1: Отправка сообщения следующему узлу
[TTL=7] Узел 2: Отправка сообщения следующему узлу
[TTL=6] Узел 3: Получено сообщение от узла -1: 'Первое сообщение от главного потока'
Узел 3: Отправляю новое сообщение узлу 1: 'Тестовое сообщение 3'
```

## Структуры данных

### Token
```go
type Token struct {
    Data     string // Данные сообщения
    Receiver []byte // Хеш получателя (SHA3-256)
    TTL      int    // Время жизни
    Sender   int    // ID отправителя
}
```

### Node
```go
type Node struct {
    ID           int         // Идентификатор узла
    Incoming     <-chan Token // Входящий канал
    Outgoing     chan<- Token // Исходящий канал
    NodesCount   int         // Общее количество узлов
    MessageCount int         // Счетчик обработанных сообщений
}
```

## Алгоритм работы узла

1. Получить сообщение из входящего канала
2. Проверить TTL - если истек, пропустить сообщение
3. Проверить, является ли получателем (сравнить хеши)
4. Если получатель:
   - Вывести сообщение
   - Сгенерировать новое сообщение
5. Если не получатель:
   - Уменьшить TTL
   - Переслать следующему узлу

## Генерация сообщений

Узлы автоматически генерируют сообщения со случайным содержимым:
- "Привет на 100 лет"
- "Тестовое сообщение" 
- "Данные для обработки"
- "Простой мусор"
- "Вирус PETYA"
- "Троянский конь"
